"""
Toy recommender to mimic the high-level Twitter pipeline on synthetic data.

Steps:
1) Load tweets.csv and engagements.csv (generated by synthetic_tweets.py)
2) Build bipartite graph (users <-> tweets) with engagement weights
3) Run a SALSA-style random walk from the target userâ€™s recent engagements
4) Score and rank tweets with simple features (walk score, recency, followed-author bonus)
5) Write top-K recommendations to toy_recs.csv

Run:
    python3 recommend.py --target_user 0 --top_k 50
"""

import argparse
import csv
import heapq
import math
import random
from collections import Counter, defaultdict
from datetime import datetime, timezone
from typing import Dict, List, Sequence, Tuple

random.seed(123)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("--tweets_csv", default="tweets.csv")
    parser.add_argument("--eng_csv", default="engagements.csv")
    parser.add_argument("--target_user", type=int, default=0)
    parser.add_argument("--top_k", type=int, default=50)
    parser.add_argument("--num_walks", type=int, default=300)
    parser.add_argument("--max_len", type=int, default=4)
    parser.add_argument("--reset_p", type=float, default=0.15)
    return parser.parse_args()


def load_tweets(path: str) -> Tuple[Dict[int, int], Dict[int, float], Dict[int, bool]]:
    """Return author per tweet, recency score, and in-network flag per tweet."""
    tweet_author: Dict[int, int] = {}
    recency: Dict[int, float] = {}
    in_network: Dict[int, bool] = {}

    with open(path, newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            tid = int(row["tweet_id"])
            author = int(row["author_id"])
            created_at = row["created_at"].rstrip("Z")
            ts = datetime.fromisoformat(created_at)
            age_days = max((datetime.now(timezone.utc) - ts.replace(tzinfo=timezone.utc)).total_seconds() / 86400.0, 0.01)
            recency[tid] = 1.0 / (1.0 + age_days)
            tweet_author[tid] = author
            in_network[tid] = row.get("in_network", "0") in ("1", "true", "True")
    return tweet_author, recency, in_network


def load_engagements(path: str) -> List[Tuple[int, int, float]]:
    """Return list of (user, tweet, weight)."""
    weights = {"like": 1.0, "reply": 1.5, "retweet": 2.0}
    interactions: List[Tuple[int, int, float]] = []
    with open(path, newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            user = int(row["user_id"])
            tweet = int(row["tweet_id"])
            w = weights.get(row["engagement"], 1.0)
            interactions.append((user, tweet, w))
    return interactions


def build_graph(interactions: Sequence[Tuple[int, int, float]]):
    """Build user->tweet and tweet->user adjacency with weights."""
    u2t: Dict[int, List[Tuple[int, float]]] = defaultdict(list)
    t2u: Dict[int, List[Tuple[int, float]]] = defaultdict(list)
    for u, t, w in interactions:
        u2t[u].append((t, w))
        t2u[t].append((u, w))
    return u2t, t2u


def salsa_random_walk(
    u2t,
    t2u,
    seeds: Sequence[int],
    num_walks: int,
    max_len: int,
    reset_p: float,
) -> Counter:
    scores: Counter = Counter()
    for seed in seeds:
        for _ in range(num_walks):
            cur = ("u", seed)
            for _ in range(max_len):
                if random.random() < reset_p:
                    cur = ("u", seed)
                else:
                    if cur[0] == "u":
                        neigh = u2t.get(cur[1], [])
                        if not neigh:
                            break
                        ts, ws = zip(*neigh)
                        t_choice = random.choices(ts, weights=ws, k=1)[0]
                        cur = ("t", t_choice)
                    else:
                        neigh = t2u.get(cur[1], [])
                        if not neigh:
                            break
                        us, ws = zip(*neigh)
                        u_choice = random.choices(us, weights=ws, k=1)[0]
                        cur = ("u", u_choice)
            if cur[0] == "t":
                scores[cur[1]] += 1
    return scores


def rank_tweets(
    scores: Counter,
    recency: Dict[int, float],
    tweet_author: Dict[int, int],
    followed_authors: set,
    k: int,
    alpha: float = 1.0,
    beta: float = 0.5,
    gamma: float = 0.3,
):
    """Greedy top-K using heap: score = alpha*walk + beta*recency + gamma*followed_author."""
    heap: List[Tuple[float, int]] = []
    for tid, walk_score in scores.items():
        s = alpha * walk_score + beta * recency.get(tid, 0.0) + gamma * (tweet_author.get(tid) in followed_authors)
        if len(heap) < k:
            heapq.heappush(heap, (s, tid))
        elif s > heap[0][0]:
            heapq.heapreplace(heap, (s, tid))
    return sorted(heap, reverse=True)


def main():
    args = parse_args()

    tweet_author, recency, in_net_flag = load_tweets(args.tweets_csv)
    interactions = load_engagements(args.eng_csv)
    u2t, t2u = build_graph(interactions)

    # Seeds: tweets the target user engaged with
    seeds = [t for (u, t, _) in interactions if u == args.target_user]
    if not seeds:
        print(f"No engagements for target_user={args.target_user}; using top engaged tweets as seeds.")
        # Fallback: take most engaged tweets as seeds
        top_tweets = Counter([t for (_, t, _) in interactions]).most_common(5)
        seeds = [tid for tid, _ in top_tweets]

    walk_scores = salsa_random_walk(
        u2t,
        t2u,
        seeds=seeds,
        num_walks=args.num_walks,
        max_len=args.max_len,
        reset_p=args.reset_p,
    )

    # Followed authors: use in_network flag as proxy for "followed by target"
    followed_authors = {tweet_author[tid] for tid, flag in in_net_flag.items() if flag}

    ranked = rank_tweets(
        walk_scores,
        recency,
        tweet_author,
        followed_authors=followed_authors,
        k=args.top_k,
        alpha=1.0,
        beta=0.5,
        gamma=0.3,
    )

    # Write recommendations
    out_path = "toy_recs.csv"
    with open(out_path, "w", newline="") as f:
        writer = csv.DictWriter(
            f,
            fieldnames=["rank", "tweet_id", "author_id", "score", "in_network", "recency"],
        )
        writer.writeheader()
        for rank, (score, tid) in enumerate(ranked, start=1):
            writer.writerow(
                {
                    "rank": rank,
                    "tweet_id": tid,
                    "author_id": tweet_author.get(tid),
                    "score": round(score, 4),
                    "in_network": int(in_net_flag.get(tid, False)),
                    "recency": round(recency.get(tid, 0.0), 4),
                }
            )

    print(f"Wrote {len(ranked)} recommendations to {out_path}")


if __name__ == "__main__":
    main()

